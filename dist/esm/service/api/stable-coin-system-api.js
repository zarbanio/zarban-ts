/* tslint:disable */
/* eslint-disable */
/**
 * Zarban API
 * API for Zarban services.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: info@zarban.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { __awaiter } from "tslib";
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, BaseAPI, operationServerMap } from '../base';
/**
 * StableCoinSystemApi - axios parameter creator
 * @export
 */
export const StableCoinSystemApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * approve and join ZAR token into Vat contract
         * @summary approve and join ZAR token into Vat contract
         * @param {StablecoinSystemZarjoinTxRequest} stablecoinSystemZarjoinTxRequest Approve and join Zar token into Vat contract transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveAndJoinZarTransaction: (stablecoinSystemZarjoinTxRequest_1, ...args_1) => __awaiter(this, [stablecoinSystemZarjoinTxRequest_1, ...args_1], void 0, function* (stablecoinSystemZarjoinTxRequest, options = {}) {
            // verify required parameter 'stablecoinSystemZarjoinTxRequest' is not null or undefined
            assertParamExists('approveAndJoinZarTransaction', 'stablecoinSystemZarjoinTxRequest', stablecoinSystemZarjoinTxRequest);
            const localVarPath = `/v2/stablecoinsystem/auctions/tx/zarjoin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(stablecoinSystemZarjoinTxRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create vault
         * @summary Create vault
         * @param {StablecoinSystemCreateVaultTxRequest} stablecoinSystemCreateVaultTxRequest Create vault transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStableCoinVault: (stablecoinSystemCreateVaultTxRequest_1, ...args_1) => __awaiter(this, [stablecoinSystemCreateVaultTxRequest_1, ...args_1], void 0, function* (stablecoinSystemCreateVaultTxRequest, options = {}) {
            // verify required parameter 'stablecoinSystemCreateVaultTxRequest' is not null or undefined
            assertParamExists('createStableCoinVault', 'stablecoinSystemCreateVaultTxRequest', stablecoinSystemCreateVaultTxRequest);
            const localVarPath = `/v2/stablecoinsystem/tx/createvault`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(stablecoinSystemCreateVaultTxRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deposit collateral
         * @summary Deposit collateral
         * @param {StablecoinSystemDepositCollateralTxRequest} stablecoinSystemDepositCollateralTxRequest Deposit collateral transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        depositStableCoinCollateral: (stablecoinSystemDepositCollateralTxRequest_1, ...args_1) => __awaiter(this, [stablecoinSystemDepositCollateralTxRequest_1, ...args_1], void 0, function* (stablecoinSystemDepositCollateralTxRequest, options = {}) {
            // verify required parameter 'stablecoinSystemDepositCollateralTxRequest' is not null or undefined
            assertParamExists('depositStableCoinCollateral', 'stablecoinSystemDepositCollateralTxRequest', stablecoinSystemDepositCollateralTxRequest);
            const localVarPath = `/v2/stablecoinsystem/tx/depositcollateral`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(stablecoinSystemDepositCollateralTxRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * exit Gem token (which can be used as collateral) from Vat contract
         * @summary exit Gem token (which can be used as collateral) from Vat contract
         * @param {StablecoinSystemGemexitTxRequest} stablecoinSystemGemexitTxRequest exit Zar token from Vat contract transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exitGemTransaction: (stablecoinSystemGemexitTxRequest_1, ...args_1) => __awaiter(this, [stablecoinSystemGemexitTxRequest_1, ...args_1], void 0, function* (stablecoinSystemGemexitTxRequest, options = {}) {
            // verify required parameter 'stablecoinSystemGemexitTxRequest' is not null or undefined
            assertParamExists('exitGemTransaction', 'stablecoinSystemGemexitTxRequest', stablecoinSystemGemexitTxRequest);
            const localVarPath = `/v2/stablecoinsystem/auctions/tx/gemexit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(stablecoinSystemGemexitTxRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * exit ZAR token from Vat contract
         * @summary exit ZAR token from Vat contract
         * @param {StablecoinSystemZarexitTxRequest} stablecoinSystemZarexitTxRequest exit Zar token from Vat contract transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exitZarTransaction: (stablecoinSystemZarexitTxRequest_1, ...args_1) => __awaiter(this, [stablecoinSystemZarexitTxRequest_1, ...args_1], void 0, function* (stablecoinSystemZarexitTxRequest, options = {}) {
            // verify required parameter 'stablecoinSystemZarexitTxRequest' is not null or undefined
            assertParamExists('exitZarTransaction', 'stablecoinSystemZarexitTxRequest', stablecoinSystemZarexitTxRequest);
            const localVarPath = `/v2/stablecoinsystem/auctions/tx/zarexit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(stablecoinSystemZarexitTxRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve a list of all available ilks.
         * @summary Get all Ilks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllIlks: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/v2/ilks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get collector data
         * @summary Get collector data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectorData: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/v2/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve an Ilk by providing its name.
         * @summary Get Ilk by name
         * @param {string} name Name of the ILK
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIlkByName: (name_1, ...args_1) => __awaiter(this, [name_1, ...args_1], void 0, function* (name, options = {}) {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getIlkByName', 'name', name);
            const localVarPath = `/v2/ilks/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get a vault by ID
         * @param {number} id Vault ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultById: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVaultById', 'id', id);
            const localVarPath = `/v2/vaults/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get vault events by ID
         * @param {number} id Vault ID
         * @param {GetVaultEventsByIdTypeEnum} [type] Event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultEventsById: (id_1, type_1, ...args_1) => __awaiter(this, [id_1, type_1, ...args_1], void 0, function* (id, type, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVaultEventsById', 'id', id);
            const localVarPath = `/v2/vaults/{id}/events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get vaults by owner query
         * @param {string} [owner] Ethereum address of the owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultsByOwner: (owner_1, ...args_1) => __awaiter(this, [owner_1, ...args_1], void 0, function* (owner, options = {}) {
            const localVarPath = `/v2/vaults`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * liquidate a vault
         * @summary liquidate a vault
         * @param {StablecoinSystemBarkTxRequest} stablecoinSystemBarkTxRequest Liquidate a Vault transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidateVaultTransaction: (stablecoinSystemBarkTxRequest_1, ...args_1) => __awaiter(this, [stablecoinSystemBarkTxRequest_1, ...args_1], void 0, function* (stablecoinSystemBarkTxRequest, options = {}) {
            // verify required parameter 'stablecoinSystemBarkTxRequest' is not null or undefined
            assertParamExists('liquidateVaultTransaction', 'stablecoinSystemBarkTxRequest', stablecoinSystemBarkTxRequest);
            const localVarPath = `/v2/stablecoinsystem/tx/bark`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(stablecoinSystemBarkTxRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Mint ZAR
         * @summary Mint ZAR
         * @param {StablecoinSystemMintZarTxRequest} stablecoinSystemMintZarTxRequest Mint ZAR transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintZarTransaction: (stablecoinSystemMintZarTxRequest_1, ...args_1) => __awaiter(this, [stablecoinSystemMintZarTxRequest_1, ...args_1], void 0, function* (stablecoinSystemMintZarTxRequest, options = {}) {
            // verify required parameter 'stablecoinSystemMintZarTxRequest' is not null or undefined
            assertParamExists('mintZarTransaction', 'stablecoinSystemMintZarTxRequest', stablecoinSystemMintZarTxRequest);
            const localVarPath = `/v2/stablecoinsystem/tx/mintzar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(stablecoinSystemMintZarTxRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Repay ZAR
         * @summary Repay ZAR
         * @param {StablecoinSystemRepayZarTxRequest} stablecoinSystemRepayZarTxRequest Repay ZAR transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repayZarTransaction: (stablecoinSystemRepayZarTxRequest_1, ...args_1) => __awaiter(this, [stablecoinSystemRepayZarTxRequest_1, ...args_1], void 0, function* (stablecoinSystemRepayZarTxRequest, options = {}) {
            // verify required parameter 'stablecoinSystemRepayZarTxRequest' is not null or undefined
            assertParamExists('repayZarTransaction', 'stablecoinSystemRepayZarTxRequest', stablecoinSystemRepayZarTxRequest);
            const localVarPath = `/v2/stablecoinsystem/tx/repayzar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(stablecoinSystemRepayZarTxRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * reset a auction
         * @summary reset a auction
         * @param {StablecoinSystemRedoTxRequest} stablecoinSystemRedoTxRequest Reset a Auction transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetAuctionTransaction: (stablecoinSystemRedoTxRequest_1, ...args_1) => __awaiter(this, [stablecoinSystemRedoTxRequest_1, ...args_1], void 0, function* (stablecoinSystemRedoTxRequest, options = {}) {
            // verify required parameter 'stablecoinSystemRedoTxRequest' is not null or undefined
            assertParamExists('resetAuctionTransaction', 'stablecoinSystemRedoTxRequest', stablecoinSystemRedoTxRequest);
            const localVarPath = `/v2/stablecoinsystem/auctions/tx/redo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(stablecoinSystemRedoTxRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * take a auction
         * @summary take a auction
         * @param {StablecoinSystemTakeTxRequest} stablecoinSystemTakeTxRequest Take a Auction transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        takeAuctionTransaction: (stablecoinSystemTakeTxRequest_1, ...args_1) => __awaiter(this, [stablecoinSystemTakeTxRequest_1, ...args_1], void 0, function* (stablecoinSystemTakeTxRequest, options = {}) {
            // verify required parameter 'stablecoinSystemTakeTxRequest' is not null or undefined
            assertParamExists('takeAuctionTransaction', 'stablecoinSystemTakeTxRequest', stablecoinSystemTakeTxRequest);
            const localVarPath = `/v2/stablecoinsystem/auctions/tx/take`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(stablecoinSystemTakeTxRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Withdraw collateral
         * @summary Withdraw collateral
         * @param {StablecoinSystemWithdrawCollateralTxRequest} stablecoinSystemWithdrawCollateralTxRequest Withdraw collateral transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawCollateralTransaction: (stablecoinSystemWithdrawCollateralTxRequest_1, ...args_1) => __awaiter(this, [stablecoinSystemWithdrawCollateralTxRequest_1, ...args_1], void 0, function* (stablecoinSystemWithdrawCollateralTxRequest, options = {}) {
            // verify required parameter 'stablecoinSystemWithdrawCollateralTxRequest' is not null or undefined
            assertParamExists('withdrawCollateralTransaction', 'stablecoinSystemWithdrawCollateralTxRequest', stablecoinSystemWithdrawCollateralTxRequest);
            const localVarPath = `/v2/stablecoinsystem/tx/withdrawcollateral`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(stablecoinSystemWithdrawCollateralTxRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * StableCoinSystemApi - functional programming interface
 * @export
 */
export const StableCoinSystemApiFp = function (configuration) {
    const localVarAxiosParamCreator = StableCoinSystemApiAxiosParamCreator(configuration);
    return {
        /**
         * approve and join ZAR token into Vat contract
         * @summary approve and join ZAR token into Vat contract
         * @param {StablecoinSystemZarjoinTxRequest} stablecoinSystemZarjoinTxRequest Approve and join Zar token into Vat contract transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveAndJoinZarTransaction(stablecoinSystemZarjoinTxRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.approveAndJoinZarTransaction(stablecoinSystemZarjoinTxRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['StableCoinSystemApi.approveAndJoinZarTransaction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Create vault
         * @summary Create vault
         * @param {StablecoinSystemCreateVaultTxRequest} stablecoinSystemCreateVaultTxRequest Create vault transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStableCoinVault(stablecoinSystemCreateVaultTxRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createStableCoinVault(stablecoinSystemCreateVaultTxRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['StableCoinSystemApi.createStableCoinVault']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Deposit collateral
         * @summary Deposit collateral
         * @param {StablecoinSystemDepositCollateralTxRequest} stablecoinSystemDepositCollateralTxRequest Deposit collateral transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        depositStableCoinCollateral(stablecoinSystemDepositCollateralTxRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.depositStableCoinCollateral(stablecoinSystemDepositCollateralTxRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['StableCoinSystemApi.depositStableCoinCollateral']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * exit Gem token (which can be used as collateral) from Vat contract
         * @summary exit Gem token (which can be used as collateral) from Vat contract
         * @param {StablecoinSystemGemexitTxRequest} stablecoinSystemGemexitTxRequest exit Zar token from Vat contract transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exitGemTransaction(stablecoinSystemGemexitTxRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.exitGemTransaction(stablecoinSystemGemexitTxRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['StableCoinSystemApi.exitGemTransaction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * exit ZAR token from Vat contract
         * @summary exit ZAR token from Vat contract
         * @param {StablecoinSystemZarexitTxRequest} stablecoinSystemZarexitTxRequest exit Zar token from Vat contract transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exitZarTransaction(stablecoinSystemZarexitTxRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.exitZarTransaction(stablecoinSystemZarexitTxRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['StableCoinSystemApi.exitZarTransaction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve a list of all available ilks.
         * @summary Get all Ilks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllIlks(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllIlks(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['StableCoinSystemApi.getAllIlks']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get collector data
         * @summary Get collector data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectorData(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCollectorData(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['StableCoinSystemApi.getCollectorData']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve an Ilk by providing its name.
         * @summary Get Ilk by name
         * @param {string} name Name of the ILK
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIlkByName(name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getIlkByName(name, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['StableCoinSystemApi.getIlkByName']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get a vault by ID
         * @param {number} id Vault ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultById(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getVaultById(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['StableCoinSystemApi.getVaultById']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get vault events by ID
         * @param {number} id Vault ID
         * @param {GetVaultEventsByIdTypeEnum} [type] Event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultEventsById(id, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getVaultEventsById(id, type, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['StableCoinSystemApi.getVaultEventsById']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get vaults by owner query
         * @param {string} [owner] Ethereum address of the owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultsByOwner(owner, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getVaultsByOwner(owner, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['StableCoinSystemApi.getVaultsByOwner']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * liquidate a vault
         * @summary liquidate a vault
         * @param {StablecoinSystemBarkTxRequest} stablecoinSystemBarkTxRequest Liquidate a Vault transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidateVaultTransaction(stablecoinSystemBarkTxRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.liquidateVaultTransaction(stablecoinSystemBarkTxRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['StableCoinSystemApi.liquidateVaultTransaction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Mint ZAR
         * @summary Mint ZAR
         * @param {StablecoinSystemMintZarTxRequest} stablecoinSystemMintZarTxRequest Mint ZAR transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintZarTransaction(stablecoinSystemMintZarTxRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.mintZarTransaction(stablecoinSystemMintZarTxRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['StableCoinSystemApi.mintZarTransaction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Repay ZAR
         * @summary Repay ZAR
         * @param {StablecoinSystemRepayZarTxRequest} stablecoinSystemRepayZarTxRequest Repay ZAR transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repayZarTransaction(stablecoinSystemRepayZarTxRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.repayZarTransaction(stablecoinSystemRepayZarTxRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['StableCoinSystemApi.repayZarTransaction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * reset a auction
         * @summary reset a auction
         * @param {StablecoinSystemRedoTxRequest} stablecoinSystemRedoTxRequest Reset a Auction transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetAuctionTransaction(stablecoinSystemRedoTxRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.resetAuctionTransaction(stablecoinSystemRedoTxRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['StableCoinSystemApi.resetAuctionTransaction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * take a auction
         * @summary take a auction
         * @param {StablecoinSystemTakeTxRequest} stablecoinSystemTakeTxRequest Take a Auction transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        takeAuctionTransaction(stablecoinSystemTakeTxRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.takeAuctionTransaction(stablecoinSystemTakeTxRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['StableCoinSystemApi.takeAuctionTransaction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Withdraw collateral
         * @summary Withdraw collateral
         * @param {StablecoinSystemWithdrawCollateralTxRequest} stablecoinSystemWithdrawCollateralTxRequest Withdraw collateral transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawCollateralTransaction(stablecoinSystemWithdrawCollateralTxRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.withdrawCollateralTransaction(stablecoinSystemWithdrawCollateralTxRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['StableCoinSystemApi.withdrawCollateralTransaction']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * StableCoinSystemApi - factory interface
 * @export
 */
export const StableCoinSystemApiFactory = function (configuration, basePath, axios) {
    const localVarFp = StableCoinSystemApiFp(configuration);
    return {
        /**
         * approve and join ZAR token into Vat contract
         * @summary approve and join ZAR token into Vat contract
         * @param {StablecoinSystemZarjoinTxRequest} stablecoinSystemZarjoinTxRequest Approve and join Zar token into Vat contract transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveAndJoinZarTransaction(stablecoinSystemZarjoinTxRequest, options) {
            return localVarFp.approveAndJoinZarTransaction(stablecoinSystemZarjoinTxRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create vault
         * @summary Create vault
         * @param {StablecoinSystemCreateVaultTxRequest} stablecoinSystemCreateVaultTxRequest Create vault transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStableCoinVault(stablecoinSystemCreateVaultTxRequest, options) {
            return localVarFp.createStableCoinVault(stablecoinSystemCreateVaultTxRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deposit collateral
         * @summary Deposit collateral
         * @param {StablecoinSystemDepositCollateralTxRequest} stablecoinSystemDepositCollateralTxRequest Deposit collateral transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        depositStableCoinCollateral(stablecoinSystemDepositCollateralTxRequest, options) {
            return localVarFp.depositStableCoinCollateral(stablecoinSystemDepositCollateralTxRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * exit Gem token (which can be used as collateral) from Vat contract
         * @summary exit Gem token (which can be used as collateral) from Vat contract
         * @param {StablecoinSystemGemexitTxRequest} stablecoinSystemGemexitTxRequest exit Zar token from Vat contract transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exitGemTransaction(stablecoinSystemGemexitTxRequest, options) {
            return localVarFp.exitGemTransaction(stablecoinSystemGemexitTxRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * exit ZAR token from Vat contract
         * @summary exit ZAR token from Vat contract
         * @param {StablecoinSystemZarexitTxRequest} stablecoinSystemZarexitTxRequest exit Zar token from Vat contract transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exitZarTransaction(stablecoinSystemZarexitTxRequest, options) {
            return localVarFp.exitZarTransaction(stablecoinSystemZarexitTxRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all available ilks.
         * @summary Get all Ilks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllIlks(options) {
            return localVarFp.getAllIlks(options).then((request) => request(axios, basePath));
        },
        /**
         * Get collector data
         * @summary Get collector data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectorData(options) {
            return localVarFp.getCollectorData(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an Ilk by providing its name.
         * @summary Get Ilk by name
         * @param {string} name Name of the ILK
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIlkByName(name, options) {
            return localVarFp.getIlkByName(name, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a vault by ID
         * @param {number} id Vault ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultById(id, options) {
            return localVarFp.getVaultById(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get vault events by ID
         * @param {number} id Vault ID
         * @param {GetVaultEventsByIdTypeEnum} [type] Event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultEventsById(id, type, options) {
            return localVarFp.getVaultEventsById(id, type, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get vaults by owner query
         * @param {string} [owner] Ethereum address of the owner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVaultsByOwner(owner, options) {
            return localVarFp.getVaultsByOwner(owner, options).then((request) => request(axios, basePath));
        },
        /**
         * liquidate a vault
         * @summary liquidate a vault
         * @param {StablecoinSystemBarkTxRequest} stablecoinSystemBarkTxRequest Liquidate a Vault transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liquidateVaultTransaction(stablecoinSystemBarkTxRequest, options) {
            return localVarFp.liquidateVaultTransaction(stablecoinSystemBarkTxRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Mint ZAR
         * @summary Mint ZAR
         * @param {StablecoinSystemMintZarTxRequest} stablecoinSystemMintZarTxRequest Mint ZAR transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mintZarTransaction(stablecoinSystemMintZarTxRequest, options) {
            return localVarFp.mintZarTransaction(stablecoinSystemMintZarTxRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Repay ZAR
         * @summary Repay ZAR
         * @param {StablecoinSystemRepayZarTxRequest} stablecoinSystemRepayZarTxRequest Repay ZAR transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repayZarTransaction(stablecoinSystemRepayZarTxRequest, options) {
            return localVarFp.repayZarTransaction(stablecoinSystemRepayZarTxRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * reset a auction
         * @summary reset a auction
         * @param {StablecoinSystemRedoTxRequest} stablecoinSystemRedoTxRequest Reset a Auction transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetAuctionTransaction(stablecoinSystemRedoTxRequest, options) {
            return localVarFp.resetAuctionTransaction(stablecoinSystemRedoTxRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * take a auction
         * @summary take a auction
         * @param {StablecoinSystemTakeTxRequest} stablecoinSystemTakeTxRequest Take a Auction transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        takeAuctionTransaction(stablecoinSystemTakeTxRequest, options) {
            return localVarFp.takeAuctionTransaction(stablecoinSystemTakeTxRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Withdraw collateral
         * @summary Withdraw collateral
         * @param {StablecoinSystemWithdrawCollateralTxRequest} stablecoinSystemWithdrawCollateralTxRequest Withdraw collateral transaction request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawCollateralTransaction(stablecoinSystemWithdrawCollateralTxRequest, options) {
            return localVarFp.withdrawCollateralTransaction(stablecoinSystemWithdrawCollateralTxRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * StableCoinSystemApi - object-oriented interface
 * @export
 * @class StableCoinSystemApi
 * @extends {BaseAPI}
 */
export class StableCoinSystemApi extends BaseAPI {
    /**
     * approve and join ZAR token into Vat contract
     * @summary approve and join ZAR token into Vat contract
     * @param {StablecoinSystemZarjoinTxRequest} stablecoinSystemZarjoinTxRequest Approve and join Zar token into Vat contract transaction request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StableCoinSystemApi
     */
    approveAndJoinZarTransaction(stablecoinSystemZarjoinTxRequest, options) {
        return StableCoinSystemApiFp(this.configuration).approveAndJoinZarTransaction(stablecoinSystemZarjoinTxRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create vault
     * @summary Create vault
     * @param {StablecoinSystemCreateVaultTxRequest} stablecoinSystemCreateVaultTxRequest Create vault transaction request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StableCoinSystemApi
     */
    createStableCoinVault(stablecoinSystemCreateVaultTxRequest, options) {
        return StableCoinSystemApiFp(this.configuration).createStableCoinVault(stablecoinSystemCreateVaultTxRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deposit collateral
     * @summary Deposit collateral
     * @param {StablecoinSystemDepositCollateralTxRequest} stablecoinSystemDepositCollateralTxRequest Deposit collateral transaction request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StableCoinSystemApi
     */
    depositStableCoinCollateral(stablecoinSystemDepositCollateralTxRequest, options) {
        return StableCoinSystemApiFp(this.configuration).depositStableCoinCollateral(stablecoinSystemDepositCollateralTxRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * exit Gem token (which can be used as collateral) from Vat contract
     * @summary exit Gem token (which can be used as collateral) from Vat contract
     * @param {StablecoinSystemGemexitTxRequest} stablecoinSystemGemexitTxRequest exit Zar token from Vat contract transaction request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StableCoinSystemApi
     */
    exitGemTransaction(stablecoinSystemGemexitTxRequest, options) {
        return StableCoinSystemApiFp(this.configuration).exitGemTransaction(stablecoinSystemGemexitTxRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * exit ZAR token from Vat contract
     * @summary exit ZAR token from Vat contract
     * @param {StablecoinSystemZarexitTxRequest} stablecoinSystemZarexitTxRequest exit Zar token from Vat contract transaction request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StableCoinSystemApi
     */
    exitZarTransaction(stablecoinSystemZarexitTxRequest, options) {
        return StableCoinSystemApiFp(this.configuration).exitZarTransaction(stablecoinSystemZarexitTxRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a list of all available ilks.
     * @summary Get all Ilks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StableCoinSystemApi
     */
    getAllIlks(options) {
        return StableCoinSystemApiFp(this.configuration).getAllIlks(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get collector data
     * @summary Get collector data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StableCoinSystemApi
     */
    getCollectorData(options) {
        return StableCoinSystemApiFp(this.configuration).getCollectorData(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve an Ilk by providing its name.
     * @summary Get Ilk by name
     * @param {string} name Name of the ILK
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StableCoinSystemApi
     */
    getIlkByName(name, options) {
        return StableCoinSystemApiFp(this.configuration).getIlkByName(name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a vault by ID
     * @param {number} id Vault ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StableCoinSystemApi
     */
    getVaultById(id, options) {
        return StableCoinSystemApiFp(this.configuration).getVaultById(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get vault events by ID
     * @param {number} id Vault ID
     * @param {GetVaultEventsByIdTypeEnum} [type] Event type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StableCoinSystemApi
     */
    getVaultEventsById(id, type, options) {
        return StableCoinSystemApiFp(this.configuration).getVaultEventsById(id, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get vaults by owner query
     * @param {string} [owner] Ethereum address of the owner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StableCoinSystemApi
     */
    getVaultsByOwner(owner, options) {
        return StableCoinSystemApiFp(this.configuration).getVaultsByOwner(owner, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * liquidate a vault
     * @summary liquidate a vault
     * @param {StablecoinSystemBarkTxRequest} stablecoinSystemBarkTxRequest Liquidate a Vault transaction request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StableCoinSystemApi
     */
    liquidateVaultTransaction(stablecoinSystemBarkTxRequest, options) {
        return StableCoinSystemApiFp(this.configuration).liquidateVaultTransaction(stablecoinSystemBarkTxRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Mint ZAR
     * @summary Mint ZAR
     * @param {StablecoinSystemMintZarTxRequest} stablecoinSystemMintZarTxRequest Mint ZAR transaction request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StableCoinSystemApi
     */
    mintZarTransaction(stablecoinSystemMintZarTxRequest, options) {
        return StableCoinSystemApiFp(this.configuration).mintZarTransaction(stablecoinSystemMintZarTxRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Repay ZAR
     * @summary Repay ZAR
     * @param {StablecoinSystemRepayZarTxRequest} stablecoinSystemRepayZarTxRequest Repay ZAR transaction request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StableCoinSystemApi
     */
    repayZarTransaction(stablecoinSystemRepayZarTxRequest, options) {
        return StableCoinSystemApiFp(this.configuration).repayZarTransaction(stablecoinSystemRepayZarTxRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * reset a auction
     * @summary reset a auction
     * @param {StablecoinSystemRedoTxRequest} stablecoinSystemRedoTxRequest Reset a Auction transaction request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StableCoinSystemApi
     */
    resetAuctionTransaction(stablecoinSystemRedoTxRequest, options) {
        return StableCoinSystemApiFp(this.configuration).resetAuctionTransaction(stablecoinSystemRedoTxRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * take a auction
     * @summary take a auction
     * @param {StablecoinSystemTakeTxRequest} stablecoinSystemTakeTxRequest Take a Auction transaction request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StableCoinSystemApi
     */
    takeAuctionTransaction(stablecoinSystemTakeTxRequest, options) {
        return StableCoinSystemApiFp(this.configuration).takeAuctionTransaction(stablecoinSystemTakeTxRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Withdraw collateral
     * @summary Withdraw collateral
     * @param {StablecoinSystemWithdrawCollateralTxRequest} stablecoinSystemWithdrawCollateralTxRequest Withdraw collateral transaction request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StableCoinSystemApi
     */
    withdrawCollateralTransaction(stablecoinSystemWithdrawCollateralTxRequest, options) {
        return StableCoinSystemApiFp(this.configuration).withdrawCollateralTransaction(stablecoinSystemWithdrawCollateralTxRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * @export
 */
export const GetVaultEventsByIdTypeEnum = {
    REPAY: 'repay',
    DEPOSIT: 'deposit',
    WITHDRAW: 'withdraw',
    MINT: 'mint'
};
//# sourceMappingURL=stable-coin-system-api.js.map