/* tslint:disable */
/* eslint-disable */
/**
 * Zarban API
 * API for Zarban services.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: info@zarban.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  OrderResponse,
  TimeRange,
  UpdateOrderRequest,
} from '../models/index';
import {
    OrderResponseFromJSON,
    OrderResponseToJSON,
    TimeRangeFromJSON,
    TimeRangeToJSON,
    UpdateOrderRequestFromJSON,
    UpdateOrderRequestToJSON,
} from '../models/index';

export interface GetUnfilledOrdersRequest {
    type?: GetUnfilledOrdersTypeEnum;
    hash?: string;
    status?: GetUnfilledOrdersStatusEnum;
    offerer?: string;
    filler?: string;
    decayStartTime?: TimeRange;
    decayEndTime?: TimeRange;
    deadline?: TimeRange;
    cursor?: number;
    limit?: number;
}

export interface SyncOrderRequest {
    updateOrderRequest: UpdateOrderRequest;
}

/**
 * OrdersApi - interface
 * 
 * @export
 * @interface OrdersApiInterface
 */
export interface OrdersApiInterface {
    /**
     * Get a list of unfilled orders filtered by different parameters.
     * @summary Fetch Unfilled Orders
     * @param {'limit' | 'dutch'} [type] Type of the order
     * @param {string} [hash] order hash
     * @param {'open' | 'expired' | 'error' | 'cancelled' | 'filled' | 'insufficient-funds'} [status] Status of the order
     * @param {string} [offerer] Ethereum address of the offerer
     * @param {string} [filler] Ethereum address of the filler
     * @param {TimeRange} [decayStartTime] Decay start time
     * @param {TimeRange} [decayEndTime] Decay end time
     * @param {TimeRange} [deadline] Order deadline
     * @param {number} [cursor] Cursor for pagination
     * @param {number} [limit] Limit the number of orders returned (default is 10)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    getUnfilledOrdersRaw(requestParameters: GetUnfilledOrdersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OrderResponse>>;

    /**
     * Get a list of unfilled orders filtered by different parameters.
     * Fetch Unfilled Orders
     */
    getUnfilledOrders(requestParameters: GetUnfilledOrdersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OrderResponse>;

    /**
     * updates an order entity in database
     * @summary Updates Order Entity
     * @param {UpdateOrderRequest} updateOrderRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApiInterface
     */
    syncOrderRaw(requestParameters: SyncOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Error>>;

    /**
     * updates an order entity in database
     * Updates Order Entity
     */
    syncOrder(requestParameters: SyncOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Error>;

}

/**
 * 
 */
export class OrdersApi extends runtime.BaseAPI implements OrdersApiInterface {

    /**
     * Get a list of unfilled orders filtered by different parameters.
     * Fetch Unfilled Orders
     */
    async getUnfilledOrdersRaw(requestParameters: GetUnfilledOrdersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OrderResponse>> {
        const queryParameters: any = {};

        if (requestParameters['type'] != null) {
            queryParameters['type'] = requestParameters['type'];
        }

        if (requestParameters['hash'] != null) {
            queryParameters['hash'] = requestParameters['hash'];
        }

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['offerer'] != null) {
            queryParameters['offerer'] = requestParameters['offerer'];
        }

        if (requestParameters['filler'] != null) {
            queryParameters['filler'] = requestParameters['filler'];
        }

        if (requestParameters['decayStartTime'] != null) {
            queryParameters['decayStartTime'] = requestParameters['decayStartTime'];
        }

        if (requestParameters['decayEndTime'] != null) {
            queryParameters['decayEndTime'] = requestParameters['decayEndTime'];
        }

        if (requestParameters['deadline'] != null) {
            queryParameters['deadline'] = requestParameters['deadline'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v2/orders`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OrderResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of unfilled orders filtered by different parameters.
     * Fetch Unfilled Orders
     */
    async getUnfilledOrders(requestParameters: GetUnfilledOrdersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OrderResponse> {
        const response = await this.getUnfilledOrdersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * updates an order entity in database
     * Updates Order Entity
     */
    async syncOrderRaw(requestParameters: SyncOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Error>> {
        if (requestParameters['updateOrderRequest'] == null) {
            throw new runtime.RequiredError(
                'updateOrderRequest',
                'Required parameter "updateOrderRequest" was null or undefined when calling syncOrder().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v2/orders/sync`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateOrderRequestToJSON(requestParameters['updateOrderRequest']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<Error>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * updates an order entity in database
     * Updates Order Entity
     */
    async syncOrder(requestParameters: SyncOrderRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Error> {
        const response = await this.syncOrderRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetUnfilledOrdersTypeEnum = {
    LIMIT: 'limit',
    DUTCH: 'dutch'
} as const;
export type GetUnfilledOrdersTypeEnum = typeof GetUnfilledOrdersTypeEnum[keyof typeof GetUnfilledOrdersTypeEnum];
/**
 * @export
 */
export const GetUnfilledOrdersStatusEnum = {
    OPEN: 'open',
    EXPIRED: 'expired',
    ERROR: 'error',
    CANCELLED: 'cancelled',
    FILLED: 'filled',
    INSUFFICIENT_FUNDS: 'insufficient-funds'
} as const;
export type GetUnfilledOrdersStatusEnum = typeof GetUnfilledOrdersStatusEnum[keyof typeof GetUnfilledOrdersStatusEnum];
